# Both of these functions expect as input a 3D array of the form generated by
# CreateRawSummaryArray.R.
#
# Some analysis (eg PCA) cannot cope with missing data. These functions will
# drop cells or odours in order to give a dataset without missing data.
# The choice of NALimit will affect how many cells/odours are dropped.
# NALimit=3, the default for some time now, is now too low since it will result
# in too many odours being dropped (while keeping more cells).

#' Given a raw spike summary array, return matrix without cells/odours missing data
#'
#' uses createSummarySpikesArray
createSummarySpikesMat <- function(summary_array, numSamplePoints=7, NALimit=3) {
  summary_array.sel <- createSummarySpikesArray(summary_array, numSamplePoints, NALimit)
  # Turn this into a cell x odour response matrix
  # NB final transpose is to get cell x odour (not odour x cell)
  t(apply(summary_array.sel, 1, t))
}

#' Given a raw spike summary array, drop cells/odours missing data
createSummarySpikesArray <- function(summary_array, numSamplePoints=7, NALimit=3) {
  # choose odours for which we are not missing too much data
  odours.na <- apply(summary_array, 2, function(x) sum(is.na(x))) / numSamplePoints
  odours.sel <- names(which(odours.na <= NALimit))

  # identify which cells have some spikes
  cells.sel <- names(which(apply(summary_array[, odours.sel, ], 1, function(x) sum(is.na(x)))==0))
  # Keep cells with sufficient spikes and odours
  summary_array[cells.sel, odours.sel, ]
}
